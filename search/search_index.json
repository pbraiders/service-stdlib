{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Stdlib for PBRaiders \u00b6 PBRaiders\\Stdlib is a set of components that implements general purpose utility classes and functions for different scopes. String and Array usefull functions. Reflection trait to access protected/private methods/properties. Used in test classes. Requirements \u00b6 The package requires PHP >=7.2 Note You may check if your PHP and extension versions match the platform requirements using composer diagnose and composer check-platform-reqs This requires Composer to be available as composer. Info For specifics, please examine the manifest composer.json file. Installation \u00b6 The package is installable and PSR-4 autoloadable via Composer as pbraiders/stdlib. For no dev use: composer install --no-dev For dev use: composer install Alternatively, download a release , or clone this repository, then map the Pbraiders\\Stdlib namespace to the package src/ directory. Test \u00b6 To run the unit tests at the command line, issue at the package root: composer install and then composer test This requires Composer to be available as composer. Contributing \u00b6 Thanks you for taking the time to contribute. Please fork the repository and make changes as you'd like. If you have any ideas, just open an issue and tell us what you think. Pull requests are also warmly welcome. If you encounter any bugs , please open an issue . Be sure to include a title and clear description,as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring. License \u00b6 PBRaiders\\Stdlib is open-source and is licensed under the MIT License .","title":"Stdlib"},{"location":"#stdlib-for-pbraiders","text":"PBRaiders\\Stdlib is a set of components that implements general purpose utility classes and functions for different scopes. String and Array usefull functions. Reflection trait to access protected/private methods/properties. Used in test classes.","title":"Stdlib for PBRaiders"},{"location":"#requirements","text":"The package requires PHP >=7.2 Note You may check if your PHP and extension versions match the platform requirements using composer diagnose and composer check-platform-reqs This requires Composer to be available as composer. Info For specifics, please examine the manifest composer.json file.","title":"Requirements"},{"location":"#installation","text":"The package is installable and PSR-4 autoloadable via Composer as pbraiders/stdlib. For no dev use: composer install --no-dev For dev use: composer install Alternatively, download a release , or clone this repository, then map the Pbraiders\\Stdlib namespace to the package src/ directory.","title":"Installation"},{"location":"#test","text":"To run the unit tests at the command line, issue at the package root: composer install and then composer test This requires Composer to be available as composer.","title":"Test"},{"location":"#contributing","text":"Thanks you for taking the time to contribute. Please fork the repository and make changes as you'd like. If you have any ideas, just open an issue and tell us what you think. Pull requests are also warmly welcome. If you encounter any bugs , please open an issue . Be sure to include a title and clear description,as much relevant information as possible, and a code sample or an executable test case demonstrating the expected behavior that is not occurring.","title":"Contributing"},{"location":"#license","text":"PBRaiders\\Stdlib is open-source and is licensed under the MIT License .","title":"License"},{"location":"array_intersect_key_recursive/","text":"array_intersect_key_recursive \u00b6 Recursively computes the intersection of arrays using keys for comparison. Description \u00b6 array_intersect_key_recursive ( array $array1, array $array2 ) : array Returns an array containing all the entries of array1 which have keys that are present in $filter, recursively. See array_intersect_key() . Parameters \u00b6 array1 \u00b6 The array with master keys to check. array2 \u00b6 An array to compare keys against. Return Values \u00b6 Returns an associative array containing all the entries of array1 which have keys that are present in array2. Examples \u00b6 <?php $array1 = array ( 'a' => [ 'blue' => 1 , 'red' => 2 , 'green' => 3 , 'purple' => 4 , ], 'b' => [ 'c' => [ 'blue' => 1 , 'red' => 2 , 'green' => 3 , 'purple' => 4 , ], ], ); $array2 = array ( 'a' => [ 'green' => 5 , 'blue' => 6 , 'yellow' => 7 , 'cyan' => 8 , ], 'b' => [ 'c' => [ 'red' => 5 , 'purple' => 6 , 'yellow' => 7 , 'cyan' => 8 , ], ], ); print_r ( array_intersect_key_recursive ( $array1 , $array2 ) ); ?> The above example will output: Array ( [a] => Array ( [blue] => 1 [green] => 3 ) [b] => Array ( [c] => Array ( [red] => 2 [purple] => 4 ) ) )","title":"array_intersect_key_recursive"},{"location":"array_intersect_key_recursive/#array_intersect_key_recursive","text":"Recursively computes the intersection of arrays using keys for comparison.","title":"array_intersect_key_recursive"},{"location":"array_intersect_key_recursive/#description","text":"array_intersect_key_recursive ( array $array1, array $array2 ) : array Returns an array containing all the entries of array1 which have keys that are present in $filter, recursively. See array_intersect_key() .","title":"Description"},{"location":"array_intersect_key_recursive/#parameters","text":"","title":"Parameters"},{"location":"array_intersect_key_recursive/#array1","text":"The array with master keys to check.","title":"array1"},{"location":"array_intersect_key_recursive/#array2","text":"An array to compare keys against.","title":"array2"},{"location":"array_intersect_key_recursive/#return-values","text":"Returns an associative array containing all the entries of array1 which have keys that are present in array2.","title":"Return Values"},{"location":"array_intersect_key_recursive/#examples","text":"<?php $array1 = array ( 'a' => [ 'blue' => 1 , 'red' => 2 , 'green' => 3 , 'purple' => 4 , ], 'b' => [ 'c' => [ 'blue' => 1 , 'red' => 2 , 'green' => 3 , 'purple' => 4 , ], ], ); $array2 = array ( 'a' => [ 'green' => 5 , 'blue' => 6 , 'yellow' => 7 , 'cyan' => 8 , ], 'b' => [ 'c' => [ 'red' => 5 , 'purple' => 6 , 'yellow' => 7 , 'cyan' => 8 , ], ], ); print_r ( array_intersect_key_recursive ( $array1 , $array2 ) ); ?> The above example will output: Array ( [a] => Array ( [blue] => 1 [green] => 3 ) [b] => Array ( [c] => Array ( [red] => 2 [purple] => 4 ) ) )","title":"Examples"},{"location":"array_key_search/","text":"array_key_search \u00b6 Searches the multi-dimensionnal array for a given located key and returns the value if successful. Description \u00b6 array_key_search( array $array1, array $array2 ) : ?mixed Note Defined for multi-dimensionnal array but works also for non multi-dimensionnal array. Array1 and Array2 must have same dimension. Warning The comparison is done in a case-sensitive manner. Parameters \u00b6 array1 \u00b6 An array with keys to check. array2 \u00b6 The array to compare key against. Must contains only one key by level. If array1 is multi-dimensionnal then array2 must be multi-dimensionnal too. Return Values \u00b6 Returns the value for the key if it is found in the array, NULL otherwise. Examples \u00b6 Example #1 <?php $array1 = array ( 'a' => 'a' , 'b' => [ 'c' => 'c' , 'e' => [ 'f' => 'ff' , 'g' => 'g' , ], 'd' => 'd' , ], 'h' => 'h' , ); $array2 = array ( 'b' => [ 'e' => [ 'f' => true , ], ], ); print_r ( array_key_search ( $array1 , $array2 )); ?> The above example will output: ff Example #2 <?php $array1 = array ( 'a' => 'a' , 'b' => [ 'c' => 'c' , 'e' => [ 'f' => [ 'ff' ], 'g' => 'g' , ], 'd' => 'd' , ], 'h' => 'h' , ); $array2 = array ( 'b' => [ 'e' => [ 'f' => true , ], ], ); print_r ( array_key_search ( $array1 , $array2 )); ?> The above example will output: Array ( [0] => ff ) Example #3 <?php $array1 = array ( 'a' => 'a' , 'b' => [ 'c' => 'c' , 'e' => [ 'f' => [ 'ff' ], 'g' => 'g' , ], 'd' => 'd' , ], 'h' => 'h' , ); $array2 = array ( 'b' => [ 'e' => [ 'z' => true , ], ], ); print_r ( array_key_search ( $array1 , $array2 )); ?> The above example will output: NULL","title":"array_key_search"},{"location":"array_key_search/#array_key_search","text":"Searches the multi-dimensionnal array for a given located key and returns the value if successful.","title":"array_key_search"},{"location":"array_key_search/#description","text":"array_key_search( array $array1, array $array2 ) : ?mixed Note Defined for multi-dimensionnal array but works also for non multi-dimensionnal array. Array1 and Array2 must have same dimension. Warning The comparison is done in a case-sensitive manner.","title":"Description"},{"location":"array_key_search/#parameters","text":"","title":"Parameters"},{"location":"array_key_search/#array1","text":"An array with keys to check.","title":"array1"},{"location":"array_key_search/#array2","text":"The array to compare key against. Must contains only one key by level. If array1 is multi-dimensionnal then array2 must be multi-dimensionnal too.","title":"array2"},{"location":"array_key_search/#return-values","text":"Returns the value for the key if it is found in the array, NULL otherwise.","title":"Return Values"},{"location":"array_key_search/#examples","text":"Example #1 <?php $array1 = array ( 'a' => 'a' , 'b' => [ 'c' => 'c' , 'e' => [ 'f' => 'ff' , 'g' => 'g' , ], 'd' => 'd' , ], 'h' => 'h' , ); $array2 = array ( 'b' => [ 'e' => [ 'f' => true , ], ], ); print_r ( array_key_search ( $array1 , $array2 )); ?> The above example will output: ff Example #2 <?php $array1 = array ( 'a' => 'a' , 'b' => [ 'c' => 'c' , 'e' => [ 'f' => [ 'ff' ], 'g' => 'g' , ], 'd' => 'd' , ], 'h' => 'h' , ); $array2 = array ( 'b' => [ 'e' => [ 'f' => true , ], ], ); print_r ( array_key_search ( $array1 , $array2 )); ?> The above example will output: Array ( [0] => ff ) Example #3 <?php $array1 = array ( 'a' => 'a' , 'b' => [ 'c' => 'c' , 'e' => [ 'f' => [ 'ff' ], 'g' => 'g' , ], 'd' => 'd' , ], 'h' => 'h' , ); $array2 = array ( 'b' => [ 'e' => [ 'z' => true , ], ], ); print_r ( array_key_search ( $array1 , $array2 )); ?> The above example will output: NULL","title":"Examples"},{"location":"ini_set_all/","text":"ini_set_all \u00b6 Sets the values of a PHP configuration options. Description \u00b6 ini_set_all ( array $options ) : bool Sets the values of the given PHP configuration options. The configuration options will keep these new values during the script's execution, and will be restored at the script's ending. See ini_set() . Parameters \u00b6 options \u00b6 The array should be an associative array like: [ 'php_option_name_1' => 'new_value_for_the_option', 'php_option_name_2' => 'new_value_for_the_option', ... ] Return Values \u00b6 Returns TRUE.","title":"ini_set_all"},{"location":"ini_set_all/#ini_set_all","text":"Sets the values of a PHP configuration options.","title":"ini_set_all"},{"location":"ini_set_all/#description","text":"ini_set_all ( array $options ) : bool Sets the values of the given PHP configuration options. The configuration options will keep these new values during the script's execution, and will be restored at the script's ending. See ini_set() .","title":"Description"},{"location":"ini_set_all/#parameters","text":"","title":"Parameters"},{"location":"ini_set_all/#options","text":"The array should be an associative array like: [ 'php_option_name_1' => 'new_value_for_the_option', 'php_option_name_2' => 'new_value_for_the_option', ... ]","title":"options"},{"location":"ini_set_all/#return-values","text":"Returns TRUE.","title":"Return Values"},{"location":"is_string_empty/","text":"is_string_empty \u00b6 Determine whether a string is empty. Description \u00b6 is_string_empty( string $value ) : bool Determine whether a string is considered to be empty. A string is considered empty if it's with whitespace stripped from the beginning and end and has length equal to zero. Parameters \u00b6 value \u00b6 String to be checked. Return Values \u00b6 Returns FALSE if value has a non-empty, non-whitespace value. Otherwise returns TRUE. The following values are considered to be empty: \"\" (an empty string) \" \" (a whitespaced string) The following values are considered to be non empty: \"0\" (0 as a string)","title":"is_string_empty"},{"location":"is_string_empty/#is_string_empty","text":"Determine whether a string is empty.","title":"is_string_empty"},{"location":"is_string_empty/#description","text":"is_string_empty( string $value ) : bool Determine whether a string is considered to be empty. A string is considered empty if it's with whitespace stripped from the beginning and end and has length equal to zero.","title":"Description"},{"location":"is_string_empty/#parameters","text":"","title":"Parameters"},{"location":"is_string_empty/#value","text":"String to be checked.","title":"value"},{"location":"is_string_empty/#return-values","text":"Returns FALSE if value has a non-empty, non-whitespace value. Otherwise returns TRUE. The following values are considered to be empty: \"\" (an empty string) \" \" (a whitespaced string) The following values are considered to be non empty: \"0\" (0 as a string)","title":"Return Values"},{"location":"ksort_recursive/","text":"ksort_recursive \u00b6 Recursively sorts an array by key. Description \u00b6 ksort_recursive( array &$array [, $unused = null, int $sort_flags = SORT_STRING ] ) : bool Sorts recursively an array by key, maintaining key to data correlations. See ksort() . Parameters \u00b6 array \u00b6 The input array. unused \u00b6 The index. Used through recursion. sort_flags \u00b6 You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort() . Return Values \u00b6 Returns TRUE on success or FALSE on failure. Examples \u00b6 <?php $fruits = array ( \"banana\" => [ \"d\" => \"Cavendish\" , \"a\" => \"Pisang Raja\" , \"b\" => \"Lady's Finger\" , \"c\" => \"Apple \" , ], \"apple\" => [ \"d\" => \"Cortland\" , \"a\" => \"Empire\" , \"b\" => \"Fugi\" , \"c\" => \"Gala\" , ] ); ksort_recursive ( $fruits ); print_r ( $fruits ); ?> The above example will output: Array ( [apple] => Array ( [a] => Empire [b] => Fugi [c] => Gala [d] => Cortland ) [banana] => Array ( [a] => Pisang Raja [b] => Lady's Finger [c] => Apple [d] => Cavendish ) )","title":"ksort_recursive"},{"location":"ksort_recursive/#ksort_recursive","text":"Recursively sorts an array by key.","title":"ksort_recursive"},{"location":"ksort_recursive/#description","text":"ksort_recursive( array &$array [, $unused = null, int $sort_flags = SORT_STRING ] ) : bool Sorts recursively an array by key, maintaining key to data correlations. See ksort() .","title":"Description"},{"location":"ksort_recursive/#parameters","text":"","title":"Parameters"},{"location":"ksort_recursive/#array","text":"The input array.","title":"array"},{"location":"ksort_recursive/#unused","text":"The index. Used through recursion.","title":"unused"},{"location":"ksort_recursive/#sort_flags","text":"You may modify the behavior of the sort using the optional parameter sort_flags, for details see sort() .","title":"sort_flags"},{"location":"ksort_recursive/#return-values","text":"Returns TRUE on success or FALSE on failure.","title":"Return Values"},{"location":"ksort_recursive/#examples","text":"<?php $fruits = array ( \"banana\" => [ \"d\" => \"Cavendish\" , \"a\" => \"Pisang Raja\" , \"b\" => \"Lady's Finger\" , \"c\" => \"Apple \" , ], \"apple\" => [ \"d\" => \"Cortland\" , \"a\" => \"Empire\" , \"b\" => \"Fugi\" , \"c\" => \"Gala\" , ] ); ksort_recursive ( $fruits ); print_r ( $fruits ); ?> The above example will output: Array ( [apple] => Array ( [a] => Empire [b] => Fugi [c] => Gala [d] => Cortland ) [banana] => Array ( [a] => Pisang Raja [b] => Lady's Finger [c] => Apple [d] => Cavendish ) )","title":"Examples"},{"location":"reflectiontrait/","text":"ReflectionTrait \u00b6 ReflectionTrait is an utility trait for reflection. We use it to easily add reflection methods to a PHPUnit test class. When added, the test class has methods to access tested class protected methods and properties. How to use \u00b6 <?php namespace Pbraiders ; use Pbraiders\\Stdlib\\ReflectionTrait ; class HelloWorld { protected string $name = 'Mike' ; protected function sayHelloTo ( string $name ) : string { return 'Hello ' . $name ; } } class HelloWorldTest extends \\PHPUnit\\Framework\\TestCase { use ReflectionTrait ; public function test_protected_property () { $class = new HelloWorld (); $property = $this -> getProperty ( '\\Pbraiders\\HelloWorld' , 'name' ); $actual = $property -> getValue ( $class ); $this -> assertSame ( 'Mike' , $actual ); } public function test_protected_method () { $class = new HelloWorld (); $method = $this -> getMethod ( '\\Pbraiders\\HelloWorld' , 'sayHelloTo' ); $actual = $method -> invokeArgs ( $class ,[ 'you' ]); $this -> assertSame ( 'Hello you' , $actual ); } public function test_protected_method_with_closure () { $class = new HelloWorld (); $method = $this -> getClosure ( $class , 'sayHelloTo' ); $actual = $class ( 'you' ); $this -> assertSame ( 'Hello you' , $actual ); } }","title":"ReflectionTrait"},{"location":"reflectiontrait/#reflectiontrait","text":"ReflectionTrait is an utility trait for reflection. We use it to easily add reflection methods to a PHPUnit test class. When added, the test class has methods to access tested class protected methods and properties.","title":"ReflectionTrait"},{"location":"reflectiontrait/#how-to-use","text":"<?php namespace Pbraiders ; use Pbraiders\\Stdlib\\ReflectionTrait ; class HelloWorld { protected string $name = 'Mike' ; protected function sayHelloTo ( string $name ) : string { return 'Hello ' . $name ; } } class HelloWorldTest extends \\PHPUnit\\Framework\\TestCase { use ReflectionTrait ; public function test_protected_property () { $class = new HelloWorld (); $property = $this -> getProperty ( '\\Pbraiders\\HelloWorld' , 'name' ); $actual = $property -> getValue ( $class ); $this -> assertSame ( 'Mike' , $actual ); } public function test_protected_method () { $class = new HelloWorld (); $method = $this -> getMethod ( '\\Pbraiders\\HelloWorld' , 'sayHelloTo' ); $actual = $method -> invokeArgs ( $class ,[ 'you' ]); $this -> assertSame ( 'Hello you' , $actual ); } public function test_protected_method_with_closure () { $class = new HelloWorld (); $method = $this -> getClosure ( $class , 'sayHelloTo' ); $actual = $class ( 'you' ); $this -> assertSame ( 'Hello you' , $actual ); } }","title":"How to use"}]}